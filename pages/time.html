<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Tracking - CYBER CLOCK</title>
    <link rel="stylesheet" href="/styles/main.css">
    <script src="https://unpkg.com/htmx.org@2.0.3"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body>
    <div class="main-container" x-data="{ selectedProjectId: null }">
        <div class="header-card">
            <h1 class="cyber-title" data-text="TIME TRACKER">TIME TRACKER</h1>
            <p class="cyber-subtitle">TRACK YOUR CYBER TIME</p>
        </div>
        
        <!-- Project Selection/Creation -->
        <div class="card project-card" 
             x-data="{
                 projects: [],
                 newProjectName: '',
                 editProjectName: '',
                 showNewProject: false,
                 showEditProject: false,
                 isLoading: false,
                 message: '',

                 async init() {
                     await this.loadProjects();
                     await this.setLastProject();
                 },

                 async loadProjects() {
                     try {
                         const response = await fetch('/projects/list');
                         if (response.ok) {
                             this.projects = await response.json();
                         }
                     } catch (error) {
                         console.error('Error loading projects:', error);
                     }
                 },

                 async setLastProject() {
                     try {
                         const response = await fetch('/time/entries?limit=1');
                         if (response.ok) {
                             const entries = await response.json();
                             if (entries.length > 0) {
                                 $data.selectedProjectId = entries[0].projectId;
                             }
                         }
                     } catch (error) {
                         console.error('Error getting last project:', error);
                     }
                 },

                 startEdit() {
                     if (!$data.selectedProjectId) {
                         this.message = 'Please select a project to edit';
                         return;
                     }
                     const project = this.projects.find(p => p.id === $data.selectedProjectId);
                     if (project) {
                         this.editProjectName = project.name;
                         this.showEditProject = true;
                     }
                 },

                 async updateProject() {
                     if (!this.editProjectName.trim() || !$data.selectedProjectId) return;
                     
                     this.isLoading = true;
                     try {
                         const response = await fetch(`/projects/${$data.selectedProjectId}`, {
                             method: 'PUT',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify({ name: this.editProjectName })
                         });
                         
                         if (response.ok) {
                             const updatedProject = await response.json();
                             const index = this.projects.findIndex(p => p.id === updatedProject.id);
                             if (index !== -1) {
                                 this.projects[index] = updatedProject;
                             }
                             this.editProjectName = '';
                             this.showEditProject = false;
                             this.message = 'Project updated successfully!';
                         }
                     } catch (error) {
                         console.error('Error updating project:', error);
                         this.message = 'Error updating project';
                     } finally {
                         this.isLoading = false;
                     }
                 },

                 async createProject() {
                     if (!this.newProjectName.trim()) return;
                     
                     this.isLoading = true;
                     try {
                         const response = await fetch('/projects/create', {
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify({ name: this.newProjectName })
                         });
                         
                         if (response.ok) {
                             const project = await response.json();
                             this.projects.push(project);
                             $data.selectedProjectId = project.id;
                             this.newProjectName = '';
                             this.showNewProject = false;
                             this.message = 'Project created successfully!';
                         }
                     } catch (error) {
                         console.error('Error creating project:', error);
                         this.message = 'Error creating project';
                     } finally {
                         this.isLoading = false;
                     }
                 }
             }">
            <h2 class="cyber-title-small">Project Selection</h2>
            
            <div class="project-controls">
                <template x-if="!showNewProject && !showEditProject">
                    <div class="project-select">
                        <select x-model="$data.selectedProjectId" 
                                class="cyber-select"
                                :disabled="isLoading">
                            <option value="">Select a Project</option>
                            <template x-for="project in projects" :key="project.id">
                                <option :value="project.id" x-text="project.name"></option>
                            </template>
                        </select>
                        <div class="project-actions">
                            <button class="btn" 
                                    @click="showNewProject = true"
                                    :disabled="isLoading">
                                New Project
                            </button>
                            <button class="btn edit-btn" 
                                    @click="startEdit()"
                                    :disabled="isLoading || !$data.selectedProjectId">
                                Edit Project
                            </button>
                        </div>
                    </div>
                </template>

                <template x-if="showNewProject">
                    <div class="project-create">
                        <input type="text" 
                               x-model="newProjectName"
                               class="cyber-input"
                               placeholder="Project Name"
                               :disabled="isLoading">
                        <div class="project-actions">
                            <button class="btn" 
                                    @click="createProject()"
                                    :disabled="isLoading || !newProjectName.trim()">
                                Create
                            </button>
                            <button class="btn cancel-btn" 
                                    @click="showNewProject = false"
                                    :disabled="isLoading">
                                Cancel
                            </button>
                        </div>
                    </div>
                </template>

                <template x-if="showEditProject">
                    <div class="project-create">
                        <input type="text" 
                               x-model="editProjectName"
                               class="cyber-input"
                               placeholder="Project Name"
                               :disabled="isLoading">
                        <div class="project-actions">
                            <button class="btn" 
                                    @click="updateProject()"
                                    :disabled="isLoading || !editProjectName.trim()">
                                Update
                            </button>
                            <button class="btn cancel-btn" 
                                    @click="showEditProject = false"
                                    :disabled="isLoading">
                                Cancel
                            </button>
                        </div>
                    </div>
                </template>

                <div x-show="message" 
                     x-text="message"
                     class="project-message"
                     @animationend="message = ''"></div>
            </div>
        </div>
        
        <!-- Time Tracking Card -->
        <div class="card time-card" 
             x-data="{
                 isTracking: false,
                 isLoading: false,
                 startTime: null,
                 elapsedTime: 0,
                 timerInterval: null,
                 message: '',
                 description: '',

                 init() {
                     this.checkActiveTimeEntry();
                 },

                 async checkActiveTimeEntry() {
                     try {
                         const response = await fetch('/time/active');
                         if (response.ok) {
                             const timeEntry = await response.json();
                             if (timeEntry) {
                                 this.startTime = new Date(timeEntry.startTime);
                                 this.description = timeEntry.description;
                                 this.startTimer();
                             }
                         }
                     } catch (error) {
                         console.error('Error checking active time entry:', error);
                     }
                 },

                 formatTime(ms) {
                     const seconds = Math.floor((ms / 1000) % 60);
                     const minutes = Math.floor((ms / (1000 * 60)) % 60);
                     const hours = Math.floor(ms / (1000 * 60 * 60));

                     return `${hours.toString().padStart(2, '0')}:${
                         minutes.toString().padStart(2, '0')}:${
                         seconds.toString().padStart(2, '0')}`;
                 },

                 startTimer() {
                     this.isTracking = true;
                     this.timerInterval = setInterval(() => {
                         this.elapsedTime = Date.now() - this.startTime.getTime();
                     }, 1000);
                 },

                 async startTracking() {
                     if (!$data.selectedProjectId) {
                         this.message = 'Please select a project first';
                         return;
                     }
                     if (!this.description.trim()) {
                         this.message = 'Please enter what you are working on';
                         return;
                     }

                     this.isLoading = true;
                     this.message = 'Starting time tracking...';

                     try {
                         const response = await fetch('/time/start', {
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify({
                                 projectId: $data.selectedProjectId,
                                 description: this.description
                             })
                         });
                         if (response.ok) {
                             const timeEntry = await response.json();
                             this.startTime = new Date(timeEntry.startTime);
                             this.startTimer();
                             this.message = 'Time tracking started!';
                         } else {
                             throw new Error('Failed to start time tracking');
                         }
                     } catch (error) {
                         console.error('Error starting time tracking:', error);
                         this.message = 'Error starting time tracking';
                     } finally {
                         this.isLoading = false;
                     }
                 },

                 async stopTracking() {
                     this.isLoading = true;
                     try {
                         const response = await fetch('/time/stop', { 
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' }
                         });
                         
                         const data = await response.json();
                         
                         if (response.ok) {
                             if (this.timerInterval !== null) {
                                 clearInterval(this.timerInterval);
                             }
                             this.isTracking = false;
                             this.description = '';
                             this.elapsedTime = 0;
                             this.startTime = null;
                             this.message = 'Time tracking stopped!';
                             
                             // Dispatch event to refresh summary
                             document.dispatchEvent(new CustomEvent('time-entry-updated'));
                         } else {
                             throw new Error(data.error || 'Failed to stop time tracking');
                         }
                     } catch (error) {
                         console.error('Error stopping time tracking:', error);
                         this.message = error instanceof Error ? error.message : 'Error stopping time tracking';
                     } finally {
                         this.isLoading = false;
                     }
                 }
             }">
            
            <div class="timer-display">
                <template x-if="!isTracking">
                    <div class="start-prompt">
                        <p class="cyber-subtitle">What are you working on?</p>
                        <textarea class="cyber-input description-input"
                                  x-model="description"
                                  placeholder="Enter task description..."
                                  :disabled="isLoading"></textarea>
                        <button class="btn" 
                                @click="startTracking"
                                :disabled="isLoading || !description.trim()">
                            Start Tracking
                        </button>
                    </div>
                </template>

                <template x-if="isTracking">
                    <div class="active-timer">
                        <p class="timer" x-text="formatTime(elapsedTime)"></p>
                        <p class="current-task" x-text="description"></p>
                        <div class="timer-controls">
                            <button class="btn stop-btn" 
                                    @click="stopTracking"
                                    :disabled="isLoading">
                                Stop Tracking
                            </button>
                        </div>
                    </div>
                </template>
            </div>

            <div class="timer-status" x-show="message">
                <p x-text="message"></p>
            </div>
        </div>

        <!-- Time Entries Summary -->
        <div class="card summary-card"
             x-data="{
                 entries: [],
                 isLoading: false,
                 projectName: 'Time Entries',

                 init() {
                     this.loadEntries();
                     // Listen for time entry updates
                     document.addEventListener('time-entry-updated', () => {
                         console.log('Received time-entry-updated event');
                         this.loadEntries();
                     });
                     // Watch for project changes
                     this.$watch('$data.selectedProjectId', () => {
                         this.loadEntries();
                         this.updateProjectName();
                     });
                 },

                 async updateProjectName() {
                     if (!$data.selectedProjectId) {
                         this.projectName = 'Time Entries';
                         return;
                     }
                     try {
                         const response = await fetch('/projects/list');
                         if (response.ok) {
                             const projects = await response.json();
                             const project = projects.find(p => p.id === $data.selectedProjectId);
                             this.projectName = project ? project.name : 'Time Entries';
                         }
                     } catch (error) {
                         console.error('Error getting project name:', error);
                         this.projectName = 'Time Entries';
                     }
                 },

                 async loadEntries() {
                     console.log('Loading entries...');
                     this.isLoading = true;
                     try {
                         const url = new URL('/time/entries', window.location.origin);
                         if ($data.selectedProjectId) {
                             url.searchParams.set('projectId', $data.selectedProjectId);
                         }
                         const response = await fetch(url);
                         if (response.ok) {
                             const data = await response.json();
                             console.log('Received entries:', data);
                             this.entries = data.map(entry => {
                                 const entryDate = new Date(entry.startTime);
                                 return {
                                     ...entry,
                                     editing: null,
                                     editMonth: entryDate.getMonth(),
                                     editDay: entryDate.getDate(),
                                     editYear: entryDate.getFullYear(),
                                     editHour: null,
                                     editMinute: null,
                                     editAmPm: null,
                                     editDescription: null
                                 };
                             });
                         }
                     } catch (error) {
                         console.error('Error loading time entries:', error);
                     } finally {
                         this.isLoading = false;
                     }
                 },

                 getTodayDate() {
                     return new Date();
                 },

                 openDatePicker(entry) {
                     console.log('Opening date picker for entry:', entry);
                     console.log('Entry start time:', entry.startTime);
                     const entryDate = new Date(entry.startTime);
                     console.log('Parsed entry date:', entryDate);
                     entry.editMonth = entryDate.getMonth();
                     entry.editDay = entryDate.getDate();
                     entry.editYear = entryDate.getFullYear();
                     console.log('Set values:', { month: entry.editMonth, day: entry.editDay, year: entry.editYear });
                     entry.editing = 'date';
                 },

                 formatTime(ms) {
                     const seconds = Math.floor((ms / 1000) % 60);
                     const minutes = Math.floor((ms / (1000 * 60)) % 60);
                     const hours = Math.floor(ms / (1000 * 60 * 60));

                     return `${hours.toString().padStart(2, '0')}:${
                         minutes.toString().padStart(2, '0')}:${
                         seconds.toString().padStart(2, '0')}`;
                 },

                 formatDuration(startTime, endTime) {
                     const duration = new Date(endTime || new Date()) - new Date(startTime);
                     return this.formatTime(duration);
                 },

                 format12Hour(dateStr) {
                     return new Date(dateStr).toLocaleTimeString('en-US', {
                         hour: 'numeric',
                         minute: '2-digit',
                         hour12: true
                     });
                 },

                 formatDate(dateStr) {
                     return new Date(dateStr).toLocaleDateString('en-US', {
                         weekday: 'short',
                         month: 'short',
                         day: 'numeric'
                     });
                 },

                 async updateTimeEntry(entryId, updates) {
                     try {
                         const response = await fetch(`/time/entries/${entryId}`, {
                             method: 'PUT',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify(updates)
                         });

                         if (response.ok) {
                             const updatedEntry = await response.json();
                             const index = this.entries.findIndex(e => e.id === entryId);
                             if (index !== -1) {
                                 this.entries[index] = {
                                     ...updatedEntry,
                                     editing: null
                                 };
                             }
                         } else {
                             throw new Error('Failed to update time entry');
                         }
                     } catch (error) {
                         console.error('Error updating time entry:', error);
                         // Reload entries to ensure consistency
                         await this.loadEntries();
                     }
                 }
             }"
             x-init="init"
             @time-entry-updated="loadEntries">
            
            <h2 class="cyber-title-small" x-text="projectName + ' Time Entries'"></h2>

            <div class="summary-table" x-show="entries.length > 0">
                <table>
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Start Time</th>
                            <th>End Time</th>
                            <th>Duration</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <template x-for="entry in entries" :key="entry.id">
                            <tr>
                                <td data-label="Date" 
                                    @click="openDatePicker(entry)">
                                    <template x-if="entry.editing !== 'date'">
                                        <div class="simple-date">
                                            <span x-text="formatDate(entry.startTime)"></span>
                                        </div>
                                    </template>
                                    <template x-if="entry.editing === 'date'">
                                        <div class="modal-wrapper" 
                                             @mousedown.self="entry.editing = null">
                                            <div class="modal-content" @click.stop>
                                                <h3 class="modal-title">Select Date</h3>
                                                <div class="date-selectors">
                                                    <select class="cyber-select month-select"
                                                            x-model.number="entry.editMonth">
                                                        <option value="0">January</option>
                                                        <option value="1">February</option>
                                                        <option value="2">March</option>
                                                        <option value="3">April</option>
                                                        <option value="4">May</option>
                                                        <option value="5">June</option>
                                                        <option value="6">July</option>
                                                        <option value="7">August</option>
                                                        <option value="8">September</option>
                                                        <option value="9">October</option>
                                                        <option value="10">November</option>
                                                        <option value="11">December</option>
                                                    </select>
                                                    <select class="cyber-select day-select"
                                                            x-model.number="entry.editDay">
                                                        <template x-for="day in [...Array(31).keys()].map(i => i + 1)">
                                                            <option :value="day" x-text="day.toString().padStart(2, '0')"></option>
                                                        </template>
                                                    </select>
                                                    <select class="cyber-select year-select"
                                                            x-model.number="entry.editYear">
                                                        <template x-for="year in Array.from({length: 10}, (_, i) => new Date().getFullYear() - 2 + i)">
                                                            <option :value="year" x-text="year"></option>
                                                        </template>
                                                    </select>
                                                </div>
                                                <div class="modal-actions">
                                                    <button class="btn" 
                                                            @click="async () => {
                                                                const newDate = new Date(entry.startTime);
                                                                newDate.setFullYear(entry.editYear);
                                                                newDate.setMonth(entry.editMonth);
                                                                newDate.setDate(entry.editDay);
                                                                await updateTimeEntry(entry.id, { startTime: newDate });
                                                                entry.editing = null;
                                                            }">
                                                        Save
                                                    </button>
                                                    <button class="btn cancel-btn" 
                                                            @click.stop="entry.editing = null">
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </td>
                                <td data-label="Start Time"
                                    @click="entry.editing = entry.editing === 'startTime' ? null : 'startTime'">
                                    <template x-if="entry.editing !== 'startTime'">
                                        <span x-text="format12Hour(entry.startTime)"></span>
                                    </template>
                                    <template x-if="entry.editing === 'startTime'">
                                        <div class="modal-wrapper" 
                                             @mousedown.self="entry.editing = null">
                                            <div class="modal-content" @click.stop>
                                                <h3 class="modal-title">Edit Start Time</h3>
                                                <div class="time-selectors">
                                                    <select class="cyber-select hour-select"
                                                            x-model="entry.editHour"
                                                            x-init="entry.editHour = new Date(entry.startTime).getHours() % 12 || 12">
                                                        <template x-for="h in [...Array(12).keys()].map(i => i + 1)">
                                                            <option :value="h" x-text="h.toString().padStart(2, '0')"></option>
                                                        </template>
                                                    </select>
                                                    <select class="cyber-select minute-select"
                                                            x-model="entry.editMinute"
                                                            x-init="entry.editMinute = new Date(entry.startTime).getMinutes()">
                                                        <template x-for="m in [...Array(60).keys()]">
                                                            <option :value="m" x-text="m.toString().padStart(2, '0')"></option>
                                                        </template>
                                                    </select>
                                                    <select class="cyber-select ampm-select"
                                                            x-model="entry.editAmPm"
                                                            x-init="entry.editAmPm = new Date(entry.startTime).getHours() >= 12 ? 'PM' : 'AM'">
                                                        <option value="AM">AM</option>
                                                        <option value="PM">PM</option>
                                                    </select>
                                                </div>
                                                <div class="modal-actions">
                                                    <button class="btn" 
                                                            @click="async () => {
                                                                let hours = parseInt(entry.editHour);
                                                                if (entry.editAmPm === 'PM' && hours !== 12) hours += 12;
                                                                if (entry.editAmPm === 'AM' && hours === 12) hours = 0;
                                                                const newDate = new Date(entry.startTime);
                                                                newDate.setHours(hours, parseInt(entry.editMinute));
                                                                await updateTimeEntry(entry.id, { startTime: newDate });
                                                                entry.editing = null;
                                                            }">
                                                        Save
                                                    </button>
                                                    <button class="btn cancel-btn" 
                                                            @click.stop="entry.editing = null">
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </td>
                                <td data-label="End Time"
                                    @click="entry.editing = entry.editing === 'endTime' ? null : 'endTime'">
                                    <template x-if="entry.editing !== 'endTime'">
                                        <span x-text="entry.endTime ? format12Hour(entry.endTime) : 'In Progress'"></span>
                                    </template>
                                    <template x-if="entry.editing === 'endTime'">
                                        <div class="modal-wrapper" 
                                             @mousedown.self="entry.editing = null">
                                            <div class="modal-content" @click.stop>
                                                <h3 class="modal-title">Edit End Time</h3>
                                                <div class="time-selectors">
                                                    <select class="cyber-select hour-select"
                                                            x-model="entry.editHour"
                                                            x-init="entry.editHour = entry.endTime ? (new Date(entry.endTime).getHours() % 12 || 12) : (new Date().getHours() % 12 || 12)">
                                                        <template x-for="h in [...Array(12).keys()].map(i => i + 1)">
                                                            <option :value="h" x-text="h.toString().padStart(2, '0')"></option>
                                                        </template>
                                                    </select>
                                                    <select class="cyber-select minute-select"
                                                            x-model="entry.editMinute"
                                                            x-init="entry.editMinute = entry.endTime ? new Date(entry.endTime).getMinutes() : new Date().getMinutes()">
                                                        <template x-for="m in [...Array(60).keys()]">
                                                            <option :value="m" x-text="m.toString().padStart(2, '0')"></option>
                                                        </template>
                                                    </select>
                                                    <select class="cyber-select ampm-select"
                                                            x-model="entry.editAmPm"
                                                            x-init="entry.editAmPm = entry.endTime ? (new Date(entry.endTime).getHours() >= 12 ? 'PM' : 'AM') : (new Date().getHours() >= 12 ? 'PM' : 'AM')">
                                                        <option value="AM">AM</option>
                                                        <option value="PM">PM</option>
                                                    </select>
                                                </div>
                                                <div class="modal-actions">
                                                    <button class="btn" 
                                                            @click="async () => {
                                                                let hours = parseInt(entry.editHour);
                                                                if (entry.editAmPm === 'PM' && hours !== 12) hours += 12;
                                                                if (entry.editAmPm === 'AM' && hours === 12) hours = 0;
                                                                const newDate = new Date(entry.startTime);
                                                                newDate.setHours(hours, parseInt(entry.editMinute));
                                                                await updateTimeEntry(entry.id, { endTime: newDate });
                                                                entry.editing = null;
                                                            }">
                                                        Save
                                                    </button>
                                                    <button class="btn cancel-btn" 
                                                            @click.stop="entry.editing = null">
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </td>
                                <td data-label="Duration" x-text="formatDuration(entry.startTime, entry.endTime)"></td>
                                <td data-label="Description"
                                    @click="entry.editing = entry.editing === 'description' ? null : 'description'">
                                    <template x-if="entry.editing !== 'description'">
                                        <span x-text="entry.description"></span>
                                    </template>
                                    <template x-if="entry.editing === 'description'">
                                        <div class="modal-wrapper"
                                             @mousedown.self="entry.editing = null">
                                            <div class="modal-content" @click.stop>
                                                <h3 class="modal-title">Edit Description</h3>
                                                <div class="modal-body">
                                                    <textarea class="cyber-input description-input"
                                                              x-model="entry.editDescription"
                                                              x-init="entry.editDescription = entry.description"
                                                              placeholder="Enter task description..."></textarea>
                                                </div>
                                                <div class="modal-actions">
                                                    <button class="btn" 
                                                            @click="async () => {
                                                                await updateTimeEntry(entry.id, { description: entry.editDescription });
                                                                entry.editing = null;
                                                            }">
                                                        Save
                                                    </button>
                                                    <button class="btn cancel-btn" 
                                                            @click.stop="entry.editing = null">
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>

            <div class="no-entries" x-show="!isLoading && entries.length === 0">
                <p>No time entries found</p>
            </div>
        </div>
    </div>
</body>
</html> 